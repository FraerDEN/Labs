= Лабораторная работа №2
:author: Газенкампф Денис Валерьевич КЭ-413
:imagesdir: pictures
:toc: left
:toc-title: Оглавление
:toclevels: 3
:figure-caption: Рисунок
:table-caption: Таблица
:stem: latexmath

== Типы данных

Тип данных – это свойство переменной, которое определяет, какие значения она может содержать и какие операции с ними можно выполнять. Типы данных и их разновидности представлены на рисунке <<pic2_1>>.

.Типы данных
[#pic2_1]
image::pic2_1.png[300x300]

*Простые типы данных*

Целые (Integral types):

- bool: логический тип данных, принимающий два значения — true или false.
- char: тип данных, предназначенный для хранения символов или небольших целых чисел.
- int: базовый тип для хранения целых чисел.
- enum: перечисление, используемое для создания набора именованных целочисленных констант.
- long: тип данных для хранения целых чисел с большим диапазоном.
- short: тип данных для хранения целых чисел с меньшим диапазоном.
- long long: тип для хранения очень больших целых чисел, с большим диапазоном, чем у long.
- unsigned: модификатор для целочисленных типов, который используется для представления только неотрицательных чисел.

С плавающей точкой (Floating-point types):

- float: тип данных, предназначенный для хранения чисел с плавающей точкой с одинарной точностью.
- double: тип данных, используемый для хранения чисел с плавающей точкой с двойной точностью.
- long double: тип данных, позволяющий хранить числа с плавающей точкой с большей точностью, чем double.

*Структурированные типы данных*

- array (массив): структура данных, предназначенная для хранения набора элементов одинакового типа.
- union (объединение): тип данных, позволяющий нескольким переменным использовать одну и ту же область памяти, но в каждый момент времени в этой области может храниться только одно значение.
- class/structure (класс/структура): пользовательский тип данных, объединяющий переменные (поля) и методы, позволяя комбинировать разные типы данных в одном объекте.

*Адресные типы данных*

- pointer (указатель): тип данных, содержащий адрес другой переменной или объекта в памяти.
- reference (ссылка): тип данных, служащий альтернативой указателю и представляющий собой ссылку на другой объект.

== К чему приводит смешивание типов данных

Смешивание разных типов данных может привести к утрате данных или снижению точности, когда значения преобразуются из одного типа в другой с меньшим диапазоном или точностью, например, при преобразовании double в int. Это может вызвать логические ошибки, непредсказуемое поведение программы или даже её сбои, особенно если преобразование выполняется автоматически и неявно, без контроля программиста. Использование явного приведения типов позволяет избежать таких ситуаций, делая поведение кода более предсказуемым.

== Неявное преобразование типов

Неявное преобразование типов происходит автоматически, когда компилятор или интерпретатор сталкивается с использованием различных типов данных в одной операции. В таком случае программа самостоятельно определяет, как привести типы к совместимому формату. Вот пример неявного преобразования типов в C++, когда теряется точность при преобразовании числа с плавающей запятой (double) в целое число (int):

[source, cpp]
----
#include <iostream>
using namespace std;

int main() 
{
    double pi = 3.14159;  // Число с плавающей запятой (double)
    int roundedPi = pi;   // Неявное преобразование double в int

    cout << "Оригинальное значение (double): " << pi << endl;
    cout << "После преобразования в int (потеря точности): " << roundedPi << endl;

    return 0;
}
----
В этом примере переменная pi хранит значение числа с плавающей запятой 3.14159. При присваивании этого значения переменной типа int происходит неявное преобразование, при котором дробная часть теряется, и в переменную roundedPi записывается только целая часть — 3. Таким образом, точность теряется, так как дробная часть числа не сохраняется.

== Явное преобразование типов

Явное преобразование типов – это преобразование, которое программист выполняет вручную, указывая, как именно нужно изменить тип данных. В C++ это делается с помощью операторов приведения типов. Явное преобразование позволяет избежать неявных и потенциально опасных преобразований, предоставляя полный контроль над тем, как значения преобразуются. 
В C++ явное преобразование типов можно выполнять с помощью стандартных операторов приведения типов, таких как static_cast, dynamic_cast, const_cast, и reinterpret_cast. Ниже приведён пример явного преобразования типов с использованием оператора static_cast:

[source, cpp]
----
#include <iostream>
using namespace std;

int main() {
    double pi = 3.14159;    // Число с плавающей запятой (double)
    
    // Явное преобразование double в int с помощью static_cast
    int roundedPi = static_cast<int>(pi);  

    cout << "Оригинальное значение (double): " << pi << endl;
    cout << "После явного преобразования в int: " << roundedPi << endl;

    return 0;
}
----
В этом примере Переменная pi хранит число с плавающей запятой (3.14159). С помощью оператора static_cast<int> выполняется явное преобразование типа double в тип int. В результате преобразования дробная часть числа отбрасывается, и в переменной roundedPi хранится только целая часть — 3. 
Здесь, в случае использования явного преобразования, мы явно указываем, что хотим преобразовать значение типа double в тип int, и это делает код более понятным и предсказуемым.

== Размеры типов

Таблица <<Размеры и диапазон значений типов>> показывает соответствие типов данных и их размеров в байтах для стандартных типов. Используется компилятор для ARM 32 битный. По умолчанию числовые типы – знаковые. Они имеют диапазон значений от -2^(n-1) до 2^(n-1), где n – количество битов, занимаемых типом. Приставка unsigned перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до 2^n-1.

[#Размеры и диапазон значений типов ]
.Размеры и диапазон значений типов
[options="header"]
[cols="2,1,7"]
|============
| *Тип данных* | *Размер (байт)* | *Диапазон значений*

| *bool* | 1 | false (0) или true (1)
| *char* | 1 | От -128 до 127 (signed) или от 0 до 255 (unsigned)
| *wchar_t* | 4 | От 0 до 4,294,967,295 (широкие символы)
| *short* | 2 | От -32,768 до 32,767
| *unsigned short* | 2 | От 0 до 65,535
| *int* | 4 | От -2,147,483,648 до 2,147,483,647
| *unsigned int* | 4 | От 0 до 4,294,967,295
| *long* | 4 | От -2,147,483,648 до 2,147,483,647
| *unsigned long* | 4 | От 0 до 4,294,967,295
| *long long* | 8 | От -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807
| *unsigned long long* | 8 | От 0 до 18,446,744,073,709,551,615
| *float* | 4 | ~7 значащих цифр
| *double* | 8 | ~15 значащих цифр
| *long double* | 8 | ~15 значащих цифр
| *std::int8_t* | 1 | От -128 до 127
| *std::uint8_t* | 1 | От 0 до 255
| *std::int16_t* | 2 | От -32,768 до 32,767
| *std::uint16_t* | 2 | От 0 до 65,535
| *std::int32_t* | 4 | От -2,147,483,648 до 2,147,483,647
| *std::uint32_t* | 4 | От 0 до 4,294,967,295
| *std::int64_t* | 8 | От -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807
| *std::uint64_t* | 8 | От 0 до 18,446,744,073,709,551,615
|============

== Функции преобразования

Функции преобразования типов (или кастинг) позволяют изменять тип данных переменной, чтобы использовать её в определённом контексте или выполнить операции с совместимыми типами. Существуют несколько способов преобразования типов: C-style casting, static_cast, dynamic_cast, const_cast, и reinterpret_cast. Каждый из них имеет свои особенности и применяется в различных ситуациях. Рассмотрим некоторые.

*Функция static_cast*

Этот метод используется для явного преобразования типов, которые совместимы и не требуют проверки в процессе выполнения программы. Подходит для преобразования между простыми типами (например, int в double) и для приведения указателей в иерархии классов (вверх или вниз). Пример:

[source, cpp]
----
#include <iostream>
using namespace std;

int main() 
{
    double x = 5.4;
    int y = static_cast<int>(x); // static_cast используется для преобразования double в int

    cout << "Значение y: " << y << endl; // Выведет: 5
    return 0;
}
----

*Функция reinterpret_cast*

Этот метод позволяет интерпретировать данные как другой тип без изменения их битового представления. Это опасный тип преобразования, и его следует использовать с осторожностью, так как может привести к непредсказуемым результатам. Пример:

[source, cpp]
----
#include <iostream>
using namespace std;

int main() 
{
    int a = 65;
    char* ch = reinterpret_cast<char*>(&a); // Преобразование int* в char*

    cout << "Значение ch: " << *ch << endl; // Выведет: символ 'A'
    return 0;
}
----
В этом примере reinterpret_cast используется для преобразования указателя на int в указатель на char. Он просто интерпретирует те же данные как другой тип, что может привести к неожиданным результатам, если не использовать его правильно.

*Функция const_cast*

Используется для удаления или добавления модификатора const к переменной. Обычно применяется, если есть необходимость изменить объект, который изначально был объявлен как константный. 
Пример использования функции преобразования типа const_cast. Эта функция используется для удаления или добавления квалификатора const к переменной.

[source, cpp]
----
#include <iostream>
using namespace std;

void changeValue(const int* ptr) 
{
    // Преобразование указателя, чтобы убрать const и изменить значение
    int* modifiablePtr = const_cast<int*>(ptr);
    *modifiablePtr = 100;  // Изменяем значение, несмотря на то, что указатель был const
}

int main() 
{
    int num = 42;
    const int* constPtr = &num;  // Указатель на константное целое число

    cout << "До изменения: " << num << endl;

    // Передаем указатель в функцию, которая изменит значение
    changeValue(constPtr);

    cout << "После изменения: " << num << endl;

    return 0;
}
----
В данном примере в функции changeValue передается указатель на константное целое число (const int*). С помощью const_cast<int*> убирается квалификатор const, и указатель становится неконстантным. Это позволяет изменить значение переменной, на которую указывает этот указатель, хотя исходный указатель был объявлен как const. В результате, несмотря на константность указателя, значение переменной изменяется на 100.

НО, использование const_cast для изменения данных, объявленных как const, может привести к неопределенному поведению, если исходные данные действительно были объявлены как константные (например, const int), а не просто через указатель на const.

== Распределение памяти ОЗУ в микроконтроллере

Память ОЗУ (RAM) в микроконтроллере распределяется на несколько сегментов, каждый из которых выполняет свою роль в хранении данных и организации работы программы. Рассмотрим каждый сегмент.

- Сегмент кода – это область памяти, где хранится исполняемый код программы. Он обычно находится во флэш-памяти и остаётся неизменным в процессе выполнения программы.

- Сегмент данных – предназначен для размещения глобальных и статических переменных. Он делится на две части: инициализированные данные (с предустановленными значениями) и неинициализированные данные (BSS), которые автоматически заполняются нулями.

- Сегмент стека служит для хранения локальных переменных, адресов возврата и временных данных. Стек управляется по принципу «последний пришёл — первый вышел» и расширяется вниз от верхней границы выделенной памяти.

- Куча – это область памяти, которая используется для динамического выделения памяти в процессе выполнения программы. Куча растёт вверх (по увеличению адресов памяти) и начинает заполняться сразу после сегмента глобальных и статических данных.Размер кучи может варьироваться, и если она растёт слишком сильно, она может встретиться со стеком, что приведёт к ошибке.

- Глобальные и статические переменные хранятся в сегменте данных, который разделён на область для инициализированных и неинициализированных данных. Переменные с заданными значениями размещаются в одной части, а неинициализированные — в другой, и они заполняются нулями при запуске программы.

Вся память микроконтроллера имеет 4 Гбайта последовательной памяти с адресами от 0x00000000 до 0xFFFFFFFF.

Адресное пространство памяти программы (ПЗУ) находится по адресам 0x00000000 по 0x1FFFFFFF.

Адресное пространство ОЗУ находится по адресам 0x20000000 по 0x3FFFFFFF.

Адресное пространство для регистров периферии находится по адресам с 0x40000000 по 0x5FFFFFFF.

== Указатель

Указатель – это переменная, которая хранит адрес другой переменной в памяти. Вместо того чтобы содержать непосредственное значение, указатель содержит ссылку на ячейку памяти, где это значение находится. Указатели позволяют программам эффективно управлять памятью и получать доступ к данным по их адресам. Основные функции указателя:

. Хранение адреса переменной: Указатели хранят адреса других переменных.
. Разыменование: Доступ к значению, на которое указывает указатель, с помощью оператора *.
. Передача по ссылке: Передача аргументов в функции, что позволяет изменять оригинальные данные.
. Динамическое выделение памяти: Управление памятью в куче с помощью new и delete.
. Указатели на функции: Возможность использовать указатели для вызова функций и передачи их как аргументов.
. Указатели на массивы и структуры: Итерация и доступ к элементам массивов и структур через указатели.

Пример использования указателя:

[source, cpp]
----
#include <iostream>
using namespace std;

int main() 
{
    int value = 10;     // Обычная переменная
    int* ptr = &value;  // Указатель, хранящий адрес переменной value

    cout << "Значение переменной: " << value << endl;          // Выводит: 10
    cout << "Адрес переменной: " << ptr << endl;              // Выводит адрес value
    cout << "Значение через указатель: " << *ptr << endl;     // Выводит: 10 (разыменование указателя)

    return 0;
}
----
В этом примере:

- value – обычная переменная типа int.
- ptr – указатель на int, который хранит адрес переменной value.
- Оператор & используется для получения адреса переменной.
- Оператор * (разыменование) позволяет получить значение переменной, на которую указывает указатель.

== Регистр

Регистр – это небольшая и быстрая область памяти, встроенная непосредственно в процессор, которая используется для хранения данных, управляющих сигналов и временной информации, необходимой для выполнения операций. Регистры играют ключевую роль в работе микроконтроллеров, обеспечивая быстрый доступ к данным и ускоряя выполнение команд. Основными функциями регистра являются:

- Хранение временных данных, необходимых для выполнения операций.
- Сохранение адресов памяти, указывающих, где находятся данные.
- Выполнение арифметических и логических операций, что позволяет процессору быстро манипулировать данными.

Типы регистров в микроконтроллерах:

- Общие регистры: Используются для хранения данных и промежуточных результатов.
- Регистры управления: Хранят управляющие данные, такие как флаги состояния и настройки конфигурации устройства.
- Регистры ввода-вывода (I/O регистры): Используются для управления внешними устройствами и обмена данными между микроконтроллером и периферийными устройствами.
- Регистры адресации: Хранят адреса памяти для доступа к данным и программам.

Пример использования регистра: когда микроконтроллер выполняет программу, он может загружать данные из оперативной памяти в регистры, выполнять арифметические операции в регистрах, а затем записывать результаты обратно в память. Это позволяет ускорить обработку данных и улучшить общую производительность устройства.

== Логические операции

Логические операции – это операции, которые выполняются над логическими значениями (обычно представленными как true и false), чтобы получить результат, основанный на логических отношениях. Эти операции используются в программировании, математике и логике для принятия решений, фильтрации данных и управления потоками выполнения.

Конъюнкция – это логическая операция, обозначаемая символом ∧(&) или словом "и". Она также принимает два булевых значения и возвращает истину только тогда, когда оба значения истинны.

.Таблица истинности (Конъюнкция)
[cols="1,1,1", options="header"]
|=====
| A | B | A ∧ B

| ИСТИНА | ИСТИНА | ИСТИНА
| ИСТИНА | ЛОЖЬ | ЛОЖЬ
| ЛОЖЬ | ИСТИНА | ЛОЖЬ
| ЛОЖЬ | ЛОЖЬ | ЛОЖЬ
|=====

Дизъюнкция — это логическая операция, обозначаемая символом V(|) или словом "или". Она принимает два булевых значения (истина или ложь) и возвращает истину, если хотя бы одно из значений истинно.

.Таблица истинности (Дизъюнкция)
[cols="1,1,1", options="header"]
|=====
| A | B | A V B

| ИСТИНА | ИСТИНА | ИСТИНА
| ИСТИНА | ЛОЖЬ | ИСТИНА
| ЛОЖЬ | ИСТИНА | ИСТИНА
| ЛОЖЬ | ЛОЖЬ | ЛОЖЬ
|=====

*Применение логических операций*

- Условия и управление потоком: Логические операции часто используются в условных выражениях, таких как if, while и for, для управления выполнением кода в зависимости от условий.
- Фильтрация данных: Логические операции помогают фильтровать данные на основе нескольких критериев.
- Алгоритмы и вычисления: Логические операции являются основой многих алгоритмов, включая поисковые и сортировочные алгоритмы.

== Как сбросить бит

Сброс бита – это операция, которая изменяет значение конкретного бита в двоичном числе на 0. В контексте программирования и работы с данными, сброс бита используется для управления состоянием определённых флагов или значений в переменных, представленных в двоичном формате.

Как работает сброс бита:

- Идентификация бита: Определить позицию бита, который нужно сбросить. Биты нумеруются, начиная с 0 (самый младший бит).
- Создание маски: Создать маску, которая содержит 1 в каждой позиции, кроме той, которую нужно сбросить. Например, для сброса 3-го бита в числе (где нумерация начинается с 0), маска будет выглядеть как 11110111 (если это 8-битное число).
- Применение операции AND: Использовать побитовую операцию AND с оригинальным значением и маской, чтобы сбросить нужный бит.

Пример сброса бита:

[source, cpp]
----
#include <iostream>
using namespace std;

int main() 
{
    unsigned char value = 0b11111111; // 255 в десятичной системе
    int bitToReset = 3;  // Позиция бита для сброса

    // Создание маски для сброса 3-го бита
    unsigned char mask = ~(1 << bitToReset); // Сдвиг 1 влево и инвертирование

    // Сброс 3-го бита
    value &= mask; // Применение побитового AND

    cout << "Результат после сброса 3-го бита: " << static_cast<int>(value) << endl; // Выводит: 247
    return 0;
}
----
По примеру:

- value изначально равен 11111111 (или 255 в десятичной системе).
- Мы хотим сбросить 3-й бит (считая от 0).
- Мы создаём маску 11110111 с помощью сдвига и инверсии.
- Применяем побитовое AND (&) для сброса 3-го бита. В результате - value становится 11110111 (или 247 в десятичной системе).

Если переменная объявлена как const, то она не может быть изменена напрямую. Однако для сброса бита в const переменной нужно использовать временные переменные или const_cast для явного изменения. Пример сброса бита с использованием временной переменной:

[source, cpp]
----
#include <iostream>
using namespace std;

int main() {
    const unsigned int value = 0b1111;  // Константное значение: 1111(15)
    int bitToReset = 1;                 // Сбрасываем второй бит (нумерация с 0)

    // Используем временную переменную для хранения результата
    unsigned int modifiedValue = value & ~(1 << bitToReset);

    cout << "Оригинальное значение: " << value << " (в двоичном: 0b" << bitset<4>(value) << ")" << endl;
    cout << "Значение после сброса бита: " << modifiedValue << " (в двоичном: 0b" << bitset<4>(modifiedValue) << ")" << endl;

    return 0;
}
----
В данном примере переменная value объявлена как const, поэтому её нельзя изменять. Для сброса бита используется временная переменная modifiedValue. Маска создается с помощью сдвига: 1 << bitToReset, а затем инвертируется с помощью ~. Результат сохраняется в переменную modifiedValue, не изменяя оригинальное значение value. Оригинальное значение: 15 (в двоичном: 0b1111).
Значение после сброса бита: 13 (в двоичном: 0b1101).

== Ответы на задания

. Если указатель типа Int указывает на адрес 1 и к этому указателю прибавит 1, то на какой адрес будет указывать указатель и почему? А если указатель будет типа double?

*Ответ:* 

Для указателя типа int, при увеличении его значения на 1, результат будет равен 5. Это связано с тем, что указатель типа int перемещается на 4 байта (размер указателя типа int), а затем добавляется 1. 

Что касается указателя типа double, процесс аналогичен предыдущему примеру: 1 перемножается на 8 (размер указателя типа double), и затем добавляется 1, что дает *итоговое значение 9*.

[start = 2]
. Если в ячейке по адресу 1 лежит число 10, в ячейке по адресу 2 лежит число 20, в ячейке по адресу 3 лежит число 30, в ячейке по адресу 4 лежит число 40 и если у нас указатель типа std::uint32_t указывает на адрес 1, то какое число будет в переменной b после разименовывания указателя?

*Ответ:*

Поскольку размер типа uint32_t составляет 4 байта, в ячейке будет храниться адресное число, записанное в каждом из адресов, начиная с наивысшего байта. Это число равно 0x281E140A или 673059850 в десятичном представлении.

[start = 3]
. Определить 
----
std::uint32_t ptr* = reinterpret_cast<std::uin32_t>(1);
auto b = *ptr; //чему равно b?
----
 *Ответ:* b будет равно 0x28201E0A в шестнадцатеричной системе или 673720842 в десятичной.

[start = 4]
. Определить
----
std::uint16_t* ptr = reinterpret_cast<std::uin16_t>(1);
auto b = *ptr; //чему равно b?
----
*Ответ:* b будет равно 0x140A в шестнадцатеричной системе или 5130 в десятичной.

----
auto b = "c"; //Какого типа b?
----
*Ответ:* указатель типа const char

----
auto b1 = 'c'; //Какого типа b1?
----
*Ответ:* когда используется auto, компилятор автоматически выводит тип переменной на основе значения справа от знака =. Поскольку 'c' - это символный литерал, его тип - char, поэтому b1 тоже будет типа char.

----
char a = 'A'; //В какое число переведется символ А?
----
*Ответ:* 65

