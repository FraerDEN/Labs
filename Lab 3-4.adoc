= Отчет по лабораторной работе № 3,4
:author: Газенкампф Денис Валерьевич КЭ-413
:imagesdir: pictures
:toc: left
:toc-title: Оглавление
:toclevels: 3
:figure-caption: Рисунок
:table-caption: Таблица
:stem: latexmath

В лабораторной работе №3 необходимо создать программу, которая включает и выключает светодиоды в определенной последовательности с использованием задержек. Это может быть полезно для индикации состояния системы или создания простых световых эффектов. Но перед тем как приступить к выполнению задания необходимо определить, что такое регистры, какие они бывают, что такое указатели на константу и константные указатели, что такое ссылки. Также необходимо понять как работают классы для управления светодиодами.

== Что такое регистры? Какие бывают регистры?

Регистры в микроконтроллере — это специальные области памяти, через которые можно управлять аппаратными ресурсами и периферийными устройствами микроконтроллера. Они позволяют задавать параметры работы, читать состояния, отправлять и принимать данные. Каждый регистр связан с конкретной функцией микроконтроллера, например, настройкой портов ввода-вывода (GPIO), управлением таймерами, работой с протоколами передачи данных (SPI, I2C, UART) или обработкой прерываний.

Типы регистров в микроконтроллерах:

- Общие регистры: Используются для хранения данных и промежуточных результатов.
- Регистры управления: Хранят управляющие данные, такие как флаги состояния и настройки конфигурации устройства.
- Регистры ввода-вывода (I/O регистры): Используются для управления внешними устройствами и обмена данными между микроконтроллером и периферийными устройствами.
- Регистры адресации: Хранят адреса памяти для доступа к данным и программам.

Регистры имеют фиксированные адреса в памяти микроконтроллера, и взаимодействие с ними происходит через чтение и запись по этим адресам. Обычно регистры имеют размер 8, 16 или 32 бита, в зависимости от архитектуры микроконтроллера. С их помощью можно, например, включать или отключать периферию, задавать режим работы пинов, управлять состоянием светодиодов, считывать данные с датчиков или настраивать параметры таймеров.

Работа с регистрами является низкоуровневым способом программирования микроконтроллеров, требующим точного понимания аппаратной архитектуры устройства. Для упрощения этой задачи часто используются специальные библиотеки или заголовочные файлы, содержащие символические имена регистров и их битов.

В микроконтроллерах различают несколько типов регистров в зависимости от их назначения и функциональности. Они делятся на категории:

.Регистры конфигурации

Эти регистры используются для настройки параметров периферийных устройств микроконтроллера. Например, они определяют режим работы портов ввода-вывода (ввод, вывод, альтернативная функция), источники тактирования или параметры работы протоколов передачи данных (SPI, I2C, UART).

Пример: настройка пина GPIO как выходного.

.Регистры управления
Служат для включения или отключения различных модулей микроконтроллера, управления их состояниями и активации определенных функций.

Пример: включение тактирования порта GPIO или старт таймера.

.Регистры данных
Используются для записи или чтения данных. Например, при работе с GPIO через такие регистры устанавливаются логические уровни на пинах или считывается их состояние.

Пример: чтение значения с кнопки или запись логического "1", чтобы включить светодиод.

.Регистры статуса
Хранят информацию о текущем состоянии микроконтроллера или периферийных устройств. Они могут показывать флаги готовности, ошибки или завершение операций.

Пример: проверка, завершилась ли передача данных по UART.

.Регистры прерываний
Используются для управления системой прерываний микроконтроллера. С их помощью можно включать или отключать определенные прерывания, а также проверять, какие из них произошли.

Пример: настройка обработки прерывания от таймера или внешнего пина.

.Регистры идентификации
Они содержат информацию о микроконтроллере, такую как его идентификационный номер, версия, или тип используемого ядра.

Пример: чтение уникального серийного номера микроконтроллера.

Каждая категория регистров имеет определенное предназначение, а их комбинация позволяет полноценно управлять функциональностью микроконтроллера. Для работы с ними обычно требуется знание конкретной архитектуры устройства, описанной в документации (datasheet и reference manual).

== Что такое указатели? Их особенности.
Указатель – это переменная, которая хранит адрес другой переменной в памяти. Вместо того чтобы содержать непосредственное значение, указатель содержит ссылку на ячейку памяти, где это значение находится. Указатели позволяют программам эффективно управлять памятью и получать доступ к данным по их адресам. Основные функции указателя:

. Хранение адреса переменной: Указатели хранят адреса других переменных.
. Разыменование: Доступ к значению, на которое указывает указатель, с помощью оператора *.
. Динамическое выделение памяти: Управление памятью в куче с помощью new и delete.
. Указатели на функции: Возможность использовать указатели для вызова функций и передачи их как аргументов.
. Указатели на массивы и структуры: Итерация и доступ к элементам массивов и структур через указатели.

Особенности указателей в микроконтроллерах.

.Прямой доступ к аппаратуре
Указатели используются для обращения к регистрам микроконтроллера, которые имеют фиксированные адреса в памяти. Это позволяет разработчику изменять состояния регистров или считывать их значения.

.Экономия ресурсов
Использование указателей позволяет работать с памятью напрямую, без копирования данных, что особенно важно в устройствах с ограниченной оперативной памятью.

.Гибкость
Указатели позволяют писать универсальный код, который может работать с различными структурами данных, массивами и памятью.

.Пример использования указателя:

[source, cpp]
----
#include <iostream>
using namespace std;

int main() 
{
    int value = 10;     // Обычная переменная
    int* ptr = &value;  // Указатель, хранящий адрес переменной value

    cout << "Значение переменной: " << value << endl;          // Выводит: 10
    cout << "Адрес переменной: " << ptr << endl;              // Выводит адрес value
    cout << "Значение через указатель: " << *ptr << endl;     // Выводит: 10 (разыменование указателя)

    return 0;
}
----
В этом примере:

- value – обычная переменная типа int.
- ptr – указатель на int, который хранит адрес переменной value.
- Оператор & используется для получения адреса переменной.
- Оператор * (разыменование) позволяет получить значение переменной, на которую указывает указатель.

== Что такое указатель на константу и константный указатель?

Указатель на константу — это указатель, который ссылается на данные, которые нельзя изменить через этот указатель. Это не означает, что данные, на которые он указывает, полностью неизменяемы, но сам указатель не позволяет их модифицировать.

В языке C++ это определяется с помощью ключевого слова const. Такой указатель обеспечивает защиту от случайной модификации данных через него, что делает программу более безопасной и читаемой.

Объявление указателя на константу выглядит так:

[source, cpp]
----
const int* ptr;
----
- const int* ptr; означает, что указатель ptr указывает на данные типа int, которые нельзя изменять через этот указатель.
- Однако сам указатель ptr можно переместить, чтобы он указывал на другой объект.

.Пример: Указатель на константу

[source, cpp]
----
const int value = 10;
const int* ptr = &value; // Указатель на константу

*ptr = 20; // Ошибка: нельзя изменять значение через указатель на константу
ptr = nullptr; // Это разрешено: указатель можно переназначить
----
- Указатель ptr не позволяет изменять данные, на которые он указывает.
- Сам указатель можно перенаправить на другой адрес.

.Пример: Указатель на неконстантные данные

[source, cpp]
----
int value1 = 10;
int value2 = 20;

const int* ptr = &value1; // Указатель на константу

*ptr = 15; // Ошибка: нельзя изменять значение через указатель
ptr = &value2; // Разрешено: можно перенаправить указатель
----
- Хотя ptr указывает на обычные (неконстантные) данные, он рассматривает их как константные, не позволяя их менять.

Зачем нужен указатель на константу?

. Защита данных
Если данные не должны изменяться в определенной части программы, указатель на константу предотвращает их случайную модификацию.

. Повышение читаемости и безопасности кода
Указывая, что данные неизменяемы, разработчик делает код более понятным для других программистов.

. Работа с функциями
Часто используется для передачи данных в функции, которые не должны модифицировать эти данные.

Константный указатель — это указатель, который нельзя переназначить после его инициализации. То есть, после того как он был установлен на определённый адрес, этот адрес нельзя изменить. Однако через такой указатель можно изменять данные, на которые он указывает (если они не объявлены как константа).

Константный указатель задаётся с использованием ключевого слова const, которое указывается после символа *:

[source, cpp]
----
int* const ptr;
----
Здесь:

- int* const означает, что указатель ptr является константой, то есть его нельзя переназначить.
- Данные, на которые он указывает, можно изменять (если они не константные).

.Пример: Константный указатель на изменяемые данные.

[source, cpp]
----
int value1 = 10;
int value2 = 20;

int* const ptr = &value1; // Константный указатель

*ptr = 15;  // Разрешено: можно изменить данные, на которые указывает указатель
ptr = &value2; // Ошибка: нельзя переназначить указатель
----

- Указатель ptr всегда будет указывать на value1.
- Данные по адресу value1 можно менять через ptr.

.Пример: Константный указатель на константные данные.

[source, cpp]
----
const int value = 10;
const int* const ptr = &value; // Константный указатель на константу

*ptr = 20; // Ошибка: данные неизменяемы
ptr = nullptr; // Ошибка: указатель нельзя переназначить
----
В этом случае:

- Данные, на которые указывает указатель, являются неизменяемыми.
- Сам указатель тоже не может быть переназначен.

.Пример: Константный указатель в функции.

[source, cpp]
----
void updateValue(int* const ptr) 
{
    *ptr = 42; // Разрешено: изменение данных
    ptr = nullptr; // Ошибка: указатель нельзя переназначить
}
----
Если функция принимает константный указатель, то она гарантирует, что указатель будет всегда указывать на тот же объект.

Отличие от указателя на константу.

. Константный указатель:
- Сам указатель неизменяем (не может быть переназначен).
- Данные, на которые он указывает, могут быть изменены (если они не константа).

. Указатель на константу:
- Данные, на которые указывает указатель, нельзя изменять.
- Сам указатель можно переназначить.

.Пример различий:

[source, cpp]
----
int value1 = 10, value2 = 20;

// Указатель на константу
const int* ptr1 = &value1;
*ptr1 = 15;  // Ошибка: нельзя изменить данные
ptr1 = &value2; // Разрешено: можно переназначить указатель

// Константный указатель
int* const ptr2 = &value1;
*ptr2 = 15;  // Разрешено: можно изменить данные
ptr2 = &value2; // Ошибка: нельзя переназначить указатель
----

== Ссылки

Ссылка (reference) в C++ — это альтернативное имя (алиас) для существующей переменной. Ссылка создаёт прямую связь с переменной, позволяя работать с ней под другим именем. В отличие от указателя, ссылка не может быть переназначена и всегда указывает на один и тот же объект.

Основные характеристики ссылок

. Связывается с объектом при инициализации.
После создания ссылки её нельзя изменить, чтобы она указывала на другой объект.
. Нет необходимости в разыменовании.
Для доступа к значению ссылки не нужно использовать оператор разыменования (*), как в случае с указателями.
. Ссылки не могут быть null.
Ссылка всегда должна указывать на действительный объект. Она не может быть пустой.
. Простота использования.
Ссылки упрощают передачу данных в функции, особенно при работе с большими объектами.

Синтаксис ссылки

[source, cpp]
----
int a = 10; 
int& ref = a; // Создание ссылки на переменную a
----
- int& ref создаёт ссылку ref на переменную a.
- Теперь ref и a — это два имени для одного и того же объекта.

Примеры использования ссылок

. Изменение значения переменной через ссылку

[source, cpp]
----
int a = 5;
int& ref = a;

ref = 10; // Меняет значение a
std::cout << a; // Выведет 10
----
- Здесь ref действует как имя для запроса для изменения переменной a. Изменения через ref затрагивают переменную a.

[start = 2]
. Ссылки как параметры функции

Ссылки позволяют передавать в функцию данные по ссылке, избегая копирования.

[source, cpp]
----
void increment(int& num) {
    num++;
}

int a = 5;
increment(a);
std::cout << a; // Выведет 6
----
- Функция increment получает ссылку на a, что позволяет изменять его значение.

[start = 3]
. Константные ссылки

Константная ссылка (const) позволяет предотвратить изменение данных через ссылку:

[source, cpp]
----
void printValue(const int& value) {
    std::cout << value;
}

int a = 42;
printValue(a); // Просто читает значение, не изменяя его
----
- Константные ссылки часто используются для передачи больших объектов, таких как строки или контейнеры, без копирования.

[start = 4]
. Ссылки и возврат из функции
Функция может возвращать ссылку, позволяя работать с исходным объектом:

[source, cpp]
----
int& getMax(int& x, int& y) 
{
    return (x > y) ? x : y;
}

int a = 10, b = 20;
getMax(a, b) = 50; // Изменяет значение b
std::cout << b; // Выведет 50
----

Сравнение ссылок и указателей.
[cols="1,1,1", options="header"]
|=====
| Характеристика | Ссылка | Указатель

| Переназначение | Нельзя переназначить | Можно изменить, на что указывает
| Инициализация  | Обязательна при создании | Может быть отложена
| Синтаксис      | Простой (a) | Требует разыменования (*ptr)
| Возможность быть null | Невозможно | Возможно
|=====

== Выполнение лабораторной работы №3
В третьей лабораторной работе необходимо написать код реализации свечения светодиодов на плате в виде "Ёлочки".

[source, cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ
#include  // for array

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{

}
RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{

}

RCC::APB2ENR::SYSCFGEN::Enable::Set();

return 1;
}
}

void delay(int cycles)
{
for(int i = 0; i < cycles; ++i)
{
}
}
class ILed
{
public:

virtual void Light();
virtual void Off();
virtual void Toggle();

};

class Led
{
public:
Led(std::uint32_t registrAddress, std::uint32_t pinNumber) :
registrAddr(registrAddress),
pinNum(pinNumber)
{
}

void Light()
{
GPIOC::ODR::Set(1 « pinNum);
}
void Off()
{
*reinterpret_caststd::uint32_t*(registrAddr) &= ~(1 « pinNum);
}
void Toggle()
{
GPIOC::ODR::Toggle(1 « pinNum);
}
private:
std::uint32_t registrAddr;
std::uint32_t pinNum;
};
int main()
{

RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
RCC::AHB1ENR::GPIOCEN::Enable::Set() ;

GPIOA::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER8::Output::Set() ;
GPIOC::MODER::MODER9::Output::Set() ;

constexpr std::uint32_t gpiocOdrRegAddres = 0x40020814U;
constexpr std::uint32_t gpioaOdrRegAddres = 0x40020014U;

Led led1(gpiocOdrRegAddres, 5);
Led led2(gpiocOdrRegAddres, 8);
Led led3(gpiocOdrRegAddres, 9);
Led led4(gpioaOdrRegAddres, 5);

std::array<Led*, 10> leds = {
&led1,
&led2,
&led3};

for (;;){

for(auto it: leds){
it -> Light();
delay(800000);
it -> Off();
}
}

return 1;

}
----

Этот код предназначен для управления светодиодами (LED) на микроконтроллере с использованием регистра доступа. Основные элементы программы можно разбить на несколько частей:

. Инициализация системы
Функция __low_level_init:

- Включает внутренний генератор HSI (High-Speed Internal oscillator) микроконтроллера, чтобы обеспечить базовый системный такт.
- Настраивает тактирование микроконтроллера для использования HSI.
- Включает тактирование подсистемы SYSCFG.

[source, cpp]
----
int __low_level_init(void)
{
    RCC::CR::HSION::On::Set(); // Включение HSI.
    while (RCC::CR::HSIRDY::NotReady::IsSet()) {} // Ожидание готовности HSI.

    RCC::CFGR::SW::Hsi::Set(); // Переключение на HSI как источник тактирования.
    while (!RCC::CFGR::SWS::Hsi::IsSet()) {} // Проверка успешного переключения.

    RCC::APB2ENR::SYSCFGEN::Enable::Set(); // Включение тактирования SYSCFG.

    return 1;
}
----

[start = 2]
. Функция задержки
Функция delay выполняет простую задержку путем пустого цикла:

[source, cpp]
----
void delay(int cycles)
{
    for (int i = 0; i < cycles; ++i) {}
}
----

[start = 3]
. Класс для управления светодиодами

Класс Led управляет отдельными светодиодами:

- Хранит адрес регистра управления и номер пина.
- Реализует методы для включения, выключения и переключения состояния светодиода.

[source, cpp]
----
class Led
{
public:
    Led(std::uint32_t registrAddress, std::uint32_t pinNumber) :
        registrAddr(registrAddress),
        pinNum(pinNumber) {}

    void Light() {
        GPIOC::ODR::Set(1 << pinNum); // Установить бит в регистре.
    }

    void Off() {
        *reinterpret_cast<std::uint32_t*>(registrAddr) &= ~(1 << pinNum); // Сбросить бит.
    }

    void Toggle() {
        GPIOC::ODR::Toggle(1 << pinNum); // Переключить состояние бита.
    }

private:
    std::uint32_t registrAddr; // Адрес регистра.
    std::uint32_t pinNum;      // Номер пина.
};
----

[start = 4]
. Настройка GPIO

В функции main:

- Включается тактирование для портов GPIOA и GPIOC.
- Конфигурируются пины для работы в режиме выхода.

[source, cpp]
----
RCC::AHB1ENR::GPIOAEN::Enable::Set();
RCC::AHB1ENR::GPIOCEN::Enable::Set();

GPIOA::MODER::MODER5::Output::Set();
GPIOC::MODER::MODER5::Output::Set();
GPIOC::MODER::MODER8::Output::Set();
GPIOC::MODER::MODER9::Output::Set();
----

[start = 5]
. Создание светодиодов и управление ими

- Определяются объекты Led с адресами регистров и номерами пинов.
- Создается массив указателей на светодиоды.
- Реализован бесконечный цикл, в котором светодиоды поочередно включаются, выдерживается задержка, а затем выключаются.

[source, cpp]
----
Led led1(gpiocOdrRegAddres, 5);
Led led2(gpiocOdrRegAddres, 8);
Led led3(gpiocOdrRegAddres, 9);

std::array<Led*, 10> leds = {&led1, &led2, &led3};

for (;;){
    for (auto it : leds){
        it->Light();
        delay(800000);
        it->Off();
    }
}
----

Таким образом, мы получили программу, которая включает и выключает светодиоды в определенной последовательности с использованием задержек.

== Выполнение лабораторной работы №4
В четвертой лабораторной работе необходимо написать код реализации свечения светодиодов на плате в виде "Ёлочки" и "Шахмат" с возможностью работы в разных режимах мигания.

[source, cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIO
#include 

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{

RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{
}

RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{
}

RCC::APB2ENR::SYSCFGEN::Enable::Set();

return 1;
}
}

void delay(int cycles)
{
for(int i = 0; i < cycles; ++i)
{
}
}
class ILed {
public:
virtual void Light() = 0;

virtual void Toggle() = 0;
};

template <typename TPort, int pinNumber>
class Led : public ILed {
public:

void Light() override
{
TPort::ODR::Set(1 << pinNumber);
}

void Toggle() override
{

TPort::ODR::Toggle(1 << pinNumber);
}

};
class IMode
{
public:
virtual void Update() = 0;
virtual void Init() = 0;
};

using tLeds = std::array<ILed*, 4>;
using tMode = std::array<IMode*, 2>;

class AllMode : public IMode
{
public:
AllMode(tLeds& ledsArr) : leds(ledsArr)
{
}

void Update() override
{
for(auto it: leds)
{
it -> Toggle();
}
}

void Init() override
{
for(auto it: leds)
{
it -> Light();
}
}

private:
tLeds leds;

};
class TreeMode : public IMode
{
public:
TreeMode(tLeds& ledsArr) : leds(ledsArr)
{
}

void Update() override
{
leds[currentLedIndex]->Toggle();
currentLedIndex++;
if(currentLedIndex == leds.size()){ currentLedIndex = 0;}
}

void Init() override
{
currentLedIndex = 0;
for(auto it: leds)
{
it -> Light();
}
}

private:
tLeds leds;
std::size_t currentLedIndex;

};

class ChessMode : public IMode
{
public:
ChessMode(tLeds& ledsArr) : leds(ledsArr)
{
}

void Update() override
{
for(auto it: leds)
{
it -> Toggle();
}
}

void Init() override
{
for(auto it: leds)
{
it -> Light();
}

for(std::size_t i = 0; i < leds.size(); i++)
{
if ((i % 2) == 0)
{
leds[i] -> Toggle();
};
}

}

private:
tLeds leds;

};
int main()
{

RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
GPIOA::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER8::Output::Set() ;
GPIOC::MODER::MODER9::Output::Set() ;

Led<GPIOA, 5> led1;
Led<GPIOC, 9> led2;
Led<GPIOC, 8> led3;
Led<GPIOC, 5> led4;

std::array<ILed*, 4> leds = {
&led1,
&led2,
&led3,
&led4};

AllMode allMode(leds);
TreeMode treeMode(leds);
ChessMode chessMode(leds);

IMode& mode = chessMode;
mode.Init();

for(;;)
{
mode.Update();
delay(1000000);
}

return 1;
}
----

. Функция __low_level_init как в прошлой лабораторной работе.

[source, cpp]
----
extern "C" {
int __low_level_init(void)
{
    // Включаем внутренний генератор тактов (HSI) и ожидаем его готовности
    RCC::CR::HSION::On::Set();
    while (RCC::CR::HSIRDY::NotReady::IsSet()) {}

    // Устанавливаем источник тактового сигнала (HSI)
    RCC::CFGR::SW::Hsi::Set();
    while (!RCC::CFGR::SWS::Hsi::IsSet()) {}

    // Включаем тактирование SYSCFG (система конфигурации)
    RCC::APB2ENR::SYSCFGEN::Enable::Set();

    return 1;
}
}
----
Этот код выполняет базовую инициализацию микроконтроллера:

- Включает внутренний генератор тактов HSI (High-Speed Internal) и ожидает его готовности.
- Настроивает источник тактового сигнала на HSI.
- Включает тактирование для модуля SYSCFG (система конфигурации).

[start = 2]
. Функция задержки delay

[source, cpp]
----
void delay(int cycles)
{
    for(int i = 0; i < cycles; ++i)
    {
    }
}
----
Эта функция реализует задержку, повторяя пустой цикл cycles раз. Это используется для замедления выполнения программы.

[start = 3]
. Абстракция для светодиодов (LED)

[source, cpp]
----
class ILed {
public:
    virtual void Light() = 0;
    virtual void Toggle() = 0;
};
----
Это абстрактный базовый класс для светодиодов, с двумя виртуальными методами:

- Light() — включает светодиод.
- Toggle() — меняет состояние светодиода (включить/выключить).

[start = 4]
. Класс для светодиода Led

[source, cpp]
----
template <typename TPort, int pinNumber>
class Led : public ILed {
public:
    void Light() override
    {
        TPort::ODR::Set(1 << pinNumber); // Включаем светодиод
    }

    void Toggle() override
    {
        TPort::ODR::Toggle(1 << pinNumber); // Меняем состояние светодиода
    }
};
----
Это шаблонный класс, который позволяет управлять светодиодами на заданном порту и пине. Порт и пин передаются как шаблонные параметры. Методы включают и переключают состояние светодиода.

[start = 5]
. Абстракция для режимов мигания

[source, cpp]
----
class IMode {
public:
    virtual void Update() = 0;
    virtual void Init() = 0;
};
----
Это абстракция для разных режимов мигания, например, мигание всех светодиодов или специфические последовательности. Каждый режим должен реализовывать методы Update (обновление состояния) и Init (инициализация состояния).

[start = 6]
. Режимы мигания:

- AllMode: Все светодиоды мигают одновременно.
- TreeMode: Светодиоды мигают поочередно, создавая эффект "дерева".
- ChessMode: Светодиоды мигают по чередующемуся шаблону, как шахматная доска.

Каждый из этих режимов использует методы Update и Init для изменения состояния светодиодов.

[start = 7]
. Основная функция main

[source, cpp]
----
int main()
{
    // Включаем тактирование портов A и C
    RCC::AHB1ENR::GPIOAEN::Enable::Set();
    RCC::AHB1ENR::GPIOCEN::Enable::Set();

    // Настроим пины как выходы
    GPIOA::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();

    // Инициализация светодиодов
    Led<GPIOA, 5> led1;
    Led<GPIOC, 9> led2;
    Led<GPIOC, 8> led3;
    Led<GPIOC, 5> led4;

    std::array<ILed*, 4> leds = {&led1, &led2, &led3, &led4};

    // Инициализация режимов
    AllMode allMode(leds);
    TreeMode treeMode(leds);
    ChessMode chessMode(leds);

    // Выбираем режим (например, ChessMode)
    IMode& mode = chessMode;
    mode.Init(); // Инициализация режима

    for(;;)
    {
        mode.Update(); // Обновление состояния режима
        delay(1000000); // Задержка
    }

    return 1;
}
----
В основной функции мы:

- Включаем тактирование портов GPIOA и GPIOC.
- Настроим пины 5, 8 и 9 на порту C и пин 5 на порту A как выходы.
- Создаем объекты светодиодов, привязывая их к конкретным пинам.
- Создаем и выбираем режим мигания светодиодов (в данном случае режим ChessMode).
- В бесконечном цикле обновляется состояние выбранного режима, светодиоды мигают согласно его логике.

Таким образом мы получили код, который управляет светодиодами, создавая различные визуальные эффекты, такие как мигание всех светодиодов одновременно, последовательно или в шахматном порядке. В нем используются абстракции для режимов мигания и светодиодов, что делает программу гибкой и расширяемой.