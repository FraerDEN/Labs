= Отчет по лабораторной работе № 7
:author: Газенкампф Денис Валерьевич КЭ-413
:imagesdir: pictures
:toc: left
:toc-title: Оглавление
:toclevels: 4
:figure-caption: Рисунок
:table-caption: Таблица
:stem: latexmath

== Цели и задачи лабораторной работы

Целью лабораторной работы №7 является разработка функции, обеспечивающей тактирование системы с использованием системного таймера. После этого требуется модифицировать функцию таким образом, чтобы тактирование осуществлялось с использованием второго таймера.

== Что такое таймер и зачем он нужен

*Таймер в микроконтроллере* — это аппаратный модуль, встроенный в микроконтроллер, предназначенный для подсчёта времени, отсчёта событий или генерации сигналов с определённой частотой.

*Основные задачи таймеров*:

- Измерение времени, подсчёт прошедшего времени с заданной точностью. Используется для создания задержек, временных интервалов или синхронизации
- Создание периодических сигналов для задач вроде управления ШИМ (широтно-импульсной модуляцией) или мигания светодиодов.
- Учет количества входных сигналов, таких как импульсы от датчиков.
- Генерация или захват сигналов с точным временным интервалом.
- Используется для работы с интерфейсами, такими как UART. Например, для работы с двумя платами.

Таймеры работают на основе тактового сигнала, подаваемого от системного или внешнего источника. Они могут:

- Увеличивать своё значение (счёт вверх).
- Уменьшать (счёт вниз).
- Работать циклично, возвращаясь к началу при достижении заданного предела.

Ознакомившись с датащитом нашего микроконтроллера STM32F411RET6, можно определить, что в нем используются таймеры, представленные на рисунке <<pic7_1>>:

.Таймеры в микроконтроллере
[#pic7_1]
image::pic7_1.png[]

=== Системный таймер

*Системный таймер* — это специальный таймер в микроконтроллере, который автоматически отсчитывает время и выполняет задачи, связанные с управлением временем. В микроконтроллерах ARM Cortex-M самым распространённым системным таймером является SysTick.

Системный таймер, встроенный в ядро ARMv7, является одним из самых простых и универсальных таймеров. Он поддерживается всеми микроконтроллерами на базе ядра Cortex-M4, включая STM32F411. Этот таймер предназначен для выполнения базовых задач, связанных с временными интервалами, и его функциональность доступна во всех микроконтроллерах с таким ядром.

Для настройки и работы с системным таймером используются три основных регистра:

- SysTick Control and Status Register (SYST_CSR): регистр управления и состояния, отвечающий за включение таймера, выбор источника тактового сигнала и управление прерываниями.
- LOAD: регистр, в который записывается значение для обратного отсчёта. Когда таймер достигает нуля, он сбрасывается и начинает отсчёт заново.
- VAL: регистр, содержащий текущее значение счётчика, которое уменьшается с каждым тактом.

Эти регистры обеспечивают простую и эффективную настройку системного таймера для задач, таких как создание задержек, генерация периодических событий и управление задачами в системах реального времени.

==== Регистр SysTick Control and Status Register (SYST_CSR)

*SysTick Control and Status Register (SYST_CSR)* — это регистр управления и состояния системного таймера SysTick. Он используется для включения или отключения таймера, выбора источника тактового сигнала, управления прерываниями и проверки текущего состояния таймера (например, сработало ли прерывание). Состав регистра представлен на рисунке <<pic7_2>>.

.Регистр SYST_CSR
[#pic7_2]
image::pic7_2.png[]

Также, в таблице <<table7_1>> представлены поля данного регистра.

.Поля регистра SYST_CSR
[#table7_1]
[cols="a, a, a,  7"]
|===
|Биты |Доступ |Обозначение |Описание

| 31:17
|
|
| Зарезервировано

| 16
| Read/Rewrite
| COUNTFLAG
| Показывает, дошёл ли счётчик до нуля с момента последнего считывания этого регистра:

*NoOverflow* (0) — счётчик ещё не достигал нуля

*Overflow* (1) — счётчик достигал нуля

Этот бит сбрасывается считыванием данного регистра, а также записью значения в регистр SYST_CVR. Его установка производится, когда значение cчётчика переходит из 1 в 0

| 15:3
|
|
|Зарезервировано

| 2
| Read/Write
| CLKSOURCE
| Выбирает источник синхронизации для таймера:

*ExternalClock*(0) — используется внешний источник

*CpuClock* (1) — для синхронизации используется частота процессора


| 1
| Read/Write
| TICKINT
| Определяет, будет ли генерироваться запрос на прерывание при достижении счетчиком 0:

*DisableInterrupt* (0) — запрос прерывания не выдаётся

*EnableInterrupt* (1) — запрос прерывания выдаётся

Достижением нуля считается только декремент значения счётчика, приводящий к появлению в нём нуля, но не его сброс в результате явной записи в регистр SYST_CVR

| 0
| Read/Write
| ENABLE
| Определяет, разрешена ли работа таймера (уменьшение счётчика):

*Disable*(0) — счётчик выключен

*Enable* (1) — счётчик включён

|===

=== Регистр перезагружаемого значения LOAD

*Регистр перезагружаемого значения LOAD* — это регистр системного таймера SysTick, в который записывается значение для обратного отсчёта. Когда счётчик таймера достигает нуля, он автоматически перезагружается этим значением и начинает отсчёт заново, обеспечивая периодическую работу таймера.

Данный регистр 32 битный, из которого используются только первые 24 бита. В этом регистре хранится значение, которое будет записано в системный таймер как только его счетчик достигнет 0.

=== Регистр текущего значения VAL

*Регистр текущего значения VAL* — это регистр системного таймера SysTick, который хранит текущее значение счётчика. Он уменьшается с каждым тактом таймера и сбрасывается при достижении нуля.

Это так же 32 битный регистр, из которого используются только первые 24 бита.

== Как работать с системным таймером?

Для создания задержки с использованием системного таймера необходимо выполнить следующие шаги:

. Установить значение задержки:
- В регистр LOAD записывается значение, соответствующее желаемой задержке. Поскольку счётчик таймера уменьшается на 1 за каждый такт процессора, для создания задержки в 1 мс при частоте процессора 16 МГц (HSI) нужно записать в регистр значение 
(16′000′000/1000−1)(16′000′000/1000−1). Таймер начнёт отсчёт с этого значения.

. Сбросить текущее значение счётчика:
- В регистр VAL записывается значение 0, чтобы обнулить счётчик.

. Настроить источник тактирования:
- В регистре CTRL подключается системный таймер к частоте процессора.

. Включить таймер:
- В том же регистре CTRL активируется системный таймер.

. Ожидать установки флага завершения:
- Как только счётчик достигнет нуля, в регистре ICSR в поле PENDSTSET (бит 26) будет установлен флаг, сигнализирующий о завершении задержки.

== Внедрение таймера в наш код

[source, cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC
#include <array>
#include "stkregisters.hpp" // для системного таймера
#include "scbregisters.hpp" // for ISCR register
#include "ILed.h"
#include "Led.h" 
#include "ledconfig.h" 
#include "IMode.h" //IMode
#include "allmode.h" //AllMode
#include "treemode.h" //TreeMode
#include "chessmode.h" //ChessMode
#include "modeconfig.h"
#include "IButton.h" 
#include "Button.h"
#include "ModeManager.h"

std::uint32_t SystemCoreClock = 16'000'000U;
extern "C" {
int __low_level_init(void)
{
RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{
}
RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{
}
RCC::APB2ENR::SYSCFGEN::Enable::Set();
STK::CTRL::CLKSOURCE::CpuClock::Set();
return 1;
}
}

void delay(std::uint32_t timeInMs)
{
  assert(timeInMs < 10000);
  //Посчитать значение задержки
  const auto timerDelayCounts = (SystemCoreClock / 1000U) * timeInMs;
 //Записать в регистре load значение задержки
  STK::LOAD::Write(timerDelayCounts - 1);
// Записать текущее значение задержки
  STK::VAL::Write(0);
//Включить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Enable::Set();
  while(STK::CTRL::COUNTFLAG::NoOverflow::IsSet())
  {
  }
//Отключить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Disable();
}
int main()
{
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  GPIOC::MODER::MODER13::Input::Set();
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  Led<GPIOC, 5 > led1;
  Led<GPIOC, 8 > led2;
  Led<GPIOC, 9 > led3;
  Led<GPIOA, 5 > led4;
  tLeds leds = { &led1, &led2, &led3, &led4 };
  TreeMode TreeMode(leds);
  ChessMode ChessMode(leds);
  AllMode AllMode(leds);
  tMode modes = { &TreeMode, &ChessMode, &AllMode };
  ModeManager modeManager(modes);
  modeManager.InitModeManager();
  Button<GPIOC, 13> button;
    for(;;)
    {
      modeManager.UpdateModeManager();
      if (button.IsClick())
      {
        modeManager.SwitchModeManager();
      }
      delay(2000);
    }
  return 1;
}
----

В данном коде программы мы выполняем слудующее:

. Настройка системы и таймера
- *_low_level_init*. Включает внутренний генератор HSI (16 МГц) и переключает системную частоту на этот источник, включает тактирование SYSCFG и настраивает системный таймер (SysTick) для использования тактов процессора.
- *delay*. Реализует функцию задержки в миллисекундах. Она использует SysTick, чтобы ждать заданное время, основываясь на частоте системного тактирования.

. Настройка GPIO и светодиодов
- Включается тактирование портов GPIOA и GPIOC.
- Настраиваются режимы работы выводов: GPIOC Pin 13 — вход (подключена кнопка), GPIOA Pin 5, GPIOC Pins 5, 8, 9 — выходы (светодиоды).
- Создаются объекты Led, ассоциирующие определенные выводы с интерфейсом управления светодиодами.
- Все светодиоды помещаются в массив leds для их группового управления.

. Настройка режимов работы светодиодов
- Реализованы три режима:
.. TreeMode — последовательное включение светодиодов ("ёлка").
.. ChessMode — мигание в шахматном порядке.
.. AllMode — одновременное включение всех светодиодов.
- Эти режимы объединяются в массив modes.

. Управление режимами
- Используется объект ModeManager, который:
.. Переключает режимы с помощью метода SwitchModeManager.
.. Обновляет состояние текущего режима с помощью UpdateModeManager.

. Обработка кнопки
- Создается объект Button, ассоциированный с выводом GPIOC Pin 13.
- В бесконечном цикле:
.. Проверяется состояние кнопки (button.IsClick).
.. При нажатии переключается режим работы светодиодов.
.. Каждую итерацию выполняется задержка в 2000 мс для обновления состояния.

== Основные особенности таймеров TIM2 и TIM5

Данные таймеры 32 битные и они позволяют работать:

- с инкрементальными энкодерами и датчиками Холла,
- несколько таймеров можно синхронизировать между собой.

Таймеры могут использоваться для:

- Захвата сигнала (Защелкивать значение, когда на выводе порта например 0 сменился на 1).
- Сравнения (Считать до значения в регистре сравнения и установить/сбросить/переключить вывод порта).
- Генерации ШИМ (Генерировать прямоугольный сигнал с различной скважностью на вывод порта).
- Генерации одиночного импульса.

== Таймеры TIM2 и TIM5 режим счета до значения

Мы можем запустить таймер для того чтобы моргать светодиодом один раз в какое то время. Так, постоянно проверяя значение бита UIF, как только оно установится в 1, моргнуть светодиодом.

- Используя переполнение невозможно задать таймером произвольный интервал времени.

- Производный интервал можно установить через регистр автоперезагрузки ARR. В этот регистр записывается значение, до которого будет идти счёт. Когда счётчик CNT достигает этого значения, его содержимое сбрасывается, и могут быть сгенерированы прерывания или запросы DMA, если они включены.

== Регистры для режима счёта таймера TIM2

. TIMx::CNT - это 16/32-битный счётный регистр, который накапливает значение с каждым поступившим тактовым импульсом. Он не поддерживает операцию вычитания.

. TIMx::PSC - это 16-битный регистр, используемый для деления частоты таймера. Значение коэффициента деления задаётся в этом регистре и может варьироваться от 1 до 65536.

. TIMx::ARR - это 16/32-битный регистр автоперезагрузки. В этот регистр записывается максимальное значение счёта. Когда счётчик TIMx_CNT достигает этого значения, его содержимое сбрасывается, и могут быть сгенерированы прерывания или запросы DMA, если они разрешены.

. TIMx::SR: - это регистр статуса, который отображает информацию о запросах на прерывания от таймера.

== Управляющий регистр (CR1)

Основные настройки таймера производятся через регистр CR1. На рисунке <<pic7_3>> представлены биты данного регистра и характеристики тех, которые нужны, в таблице <<table7_2>>.

.Управляющий регистр CR1
[#pic7_3]
image::pic7_3.png[]

.Биты регистра CR1
[#table7_2]
[cols="a, a, a,  7"]

[horizontal]
[cols="a, a"]
|===
|Бит | Описание

|Bit 2: URS
|Источник генерации прерываний​

* *0*: Любые из следующих событий будут генерировать прерывание или запрос DMA, если они включены:​
** Переполнение счетчика​ или установлен UG бит​
* *1*: Только после переполнения счетчика может сгенерировать прерывание или запрос DMA​

|Bit 1: UDIS
|Отключить событие по изменению (Update Event)​

* *0*: UEV включен. Событие по изменению(UEV) генерируются следующими событиями:​
 ** Переполнение счетчика​ или установлен UG бит​
* *1*: UEV отключен. ​

|Bit 0 CEN
|Включить счетчик​

* *0*: Counter выключен​
* *1*: Counter включен​
|===

== Регистр статуса (SR)

Регистр SR хранит статусы запросов на прерывания, на рисунке <<pic7_4>> представлены биты регистра, а в таблице <<table7_3>> характериситики нужного.

.Регистр SR
image::pic7_4.png[]

.Биты регистра SR
[#table7_3]
[cols="a, a"]
|===
|Бит | Описание

|Bit0: UIF
|Флаг прерывания по событию обновления. Бит устанавливается аппаратно, скидываться должен программно​

* *0*: Флаг прерывания сбршен​
* *1*: Флаг прерывания установлен​

|===

== Работа с таймером в качестве счетчика​

Для организации задержки необходимо:

- Подать тактирование на модуль таймера​
- Установить делитель частоты для таймера в регистре PSC​.
- Установить источник генерации прерываний по событию переполнение с помощью бита URS в регистре CR1​.
- Установить значение до которого счетчик будет считать в регистре перезагрузке ARR​.
- Скинуть флаг генерации прерывания UIF по событию в регистре SR​.
- Установить начальное значение счетчика в 0 в регистре CNT​.
- Запустить счетчик с помощью бита EN в регистре CR1​.
- Проверять пока не будет установлен флаг генерации прерывания по событию UIF в регистре SR​.
- Как только флаг установлен остановить счетчик, сбросить бит EN в регистре CR1, Сбросить флаг генерации прерывания UIF по событию в регистре SR.

== Внедрение таймера TIM2 в код программы

Ниже представлена реализация таймера TIM2 в коде программы.

[source, cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ
#include <array>
#include "stkregisters.hpp" // для системного таймера
#include "scbregisters.hpp" // for ISCR register
#include "tim2registers.hpp" // for TIM2
#include "ILed.h"
#include "Led.h" 
#include "ledconfig.h" 
#include "IMode.h" // IMode
#include "allmode.h" // AllMode
#include "treemode.h" // TreeMode
#include "chessmode.h" // ChessMode
#include "modeconfig.h"
#include "IButton.h"
#include "Button.h"
#include "ModeManager.h"

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{
}
RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{
}
RCC::APB1ENR::TIM2EN::Enable::Set();
return 1;
}
}
void delay(std::uint32_t timeInMs)
{
  assert(timeInMs < 10000);
  
  const auto prescalerValue = SystemCoreClock / 1000U - 1U;
  
  TIM2::PSC::Write(prescalerValue);
  
  TIM2::CR1::URS::Set(0);
  
  TIM2::ARR::Write(timeInMs);
  
  TIM2::SR::UIF::Set(0);
  
  TIM2::CNT::Write(0);
  
  TIM2::CR1::CEN::Enable::Set();
  while(TIM2::SR::UIF::NoInterruptPending::IsSet())
  {
  }
  TIM2::CR1::CEN::Disable::Set();
}

int main()
{
RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
RCC::AHB1ENR::GPIOCEN::Enable::Set();
GPIOC::MODER::MODER13::Input::Set();
GPIOA::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER5::Output::Set() ;
GPIOC::MODER::MODER8::Output::Set() ;
GPIOC::MODER::MODER9::Output::Set() ;

Led<GPIOC, 5> led1;
Led<GPIOC, 8> led2;
Led<GPIOC, 9> led3;
Led<GPIOA, 5> led4;

tLeds leds = { &led1, &led2, &led3, &led4 };

    TreeMode TreeMode(leds);
    ChessMode ChessMode(leds);
    AllMode AllMode(leds);
    tMode modes = { &TreeMode, &ChessMode, &AllMode };
    ModeManager modeManager(modes);
    modeManager.InitModeManager();
    Button<GPIOC, 13> button;
   for(;;)
  {
    modeManager.UpdateModeManager();
    if (button.IsClick())
    {
      modeManager.SwitchModeManager();
    }
    delay(2000);
  }
  
  return 1;
}
----

== Вывод по лабораторной работе

Таким образом, мы разработали код программы с внедрением функции, обеспечивающей тактирование системы с использованием системного таймера, а также модифицировали функцию таким образом, чтобы тактирование осуществлялось с использованием второго таймера (TIM2).